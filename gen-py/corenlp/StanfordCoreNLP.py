#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:utf8strings,slots,new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def ping(self, ):
    pass

  def zip(self, ):
    pass

  def parse_text(self, text, outputFormat):
    """
    Parameters:
     - text
     - outputFormat
    """
    pass

  def parse_tokens(self, tokens, outputFormat):
    """
    Parameters:
     - tokens
     - outputFormat
    """
    pass

  def parse_tagged_sentence(self, taggedSentence, outputFormat, divider):
    """
    Parameters:
     - taggedSentence
     - outputFormat
     - divider
    """
    pass

  def lexicalize_parse_tree(self, tree):
    """
    Parameters:
     - tree
    """
    pass

  def get_entities_from_text(self, text):
    """
    Parameters:
     - text
    """
    pass

  def get_entities_from_tokens(self, tokens):
    """
    Parameters:
     - tokens
    """
    pass

  def get_entities_from_trees(self, trees):
    """
    Parameters:
     - trees
    """
    pass

  def resolve_coreferences_in_text(self, text):
    """
    Parameters:
     - text
    """
    pass

  def resolve_coreferences_in_tokenized_sentences(self, sentencesWithTokensSeparatedBySpace):
    """
    Parameters:
     - sentencesWithTokensSeparatedBySpace
    """
    pass

  def resolve_coreferences_in_trees(self, trees):
    """
    Parameters:
     - trees
    """
    pass

  def evaluate_tregex_pattern(self, parseTree, tregexPattern):
    """
    Parameters:
     - parseTree
     - tregexPattern
    """
    pass

  def tag_text(self, untokenizedText):
    """
    Parameters:
     - untokenizedText
    """
    pass

  def tag_tokenized_sentence(self, tokenizedSentence):
    """
    Parameters:
     - tokenizedSentence
    """
    pass

  def untokenize_sentence(self, sentenceTokens):
    """
    Parameters:
     - sentenceTokens
    """
    pass

  def tokenize_text(self, arbitraryText):
    """
    Parameters:
     - arbitraryText
    """
    pass

  def sr_parse_tagged_sentence(self, taggedSentence, outputFormat, divider):
    """
    Parameters:
     - taggedSentence
     - outputFormat
     - divider
    """
    pass

  def sr_parse_text(self, untokenizedText, outputFormat):
    """
    Parameters:
     - untokenizedText
     - outputFormat
    """
    pass

  def sr_parse_tokens(self, tokenizedSentence, outputFormat):
    """
    Parameters:
     - tokenizedSentence
     - outputFormat
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def ping(self, ):
    self.send_ping()
    self.recv_ping()

  def send_ping(self, ):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def zip(self, ):
    self.send_zip()

  def send_zip(self, ):
    self._oprot.writeMessageBegin('zip', TMessageType.CALL, self._seqid)
    args = zip_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def parse_text(self, text, outputFormat):
    """
    Parameters:
     - text
     - outputFormat
    """
    self.send_parse_text(text, outputFormat)
    return self.recv_parse_text()

  def send_parse_text(self, text, outputFormat):
    self._oprot.writeMessageBegin('parse_text', TMessageType.CALL, self._seqid)
    args = parse_text_args()
    args.text = text
    args.outputFormat = outputFormat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_parse_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = parse_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "parse_text failed: unknown result");

  def parse_tokens(self, tokens, outputFormat):
    """
    Parameters:
     - tokens
     - outputFormat
    """
    self.send_parse_tokens(tokens, outputFormat)
    return self.recv_parse_tokens()

  def send_parse_tokens(self, tokens, outputFormat):
    self._oprot.writeMessageBegin('parse_tokens', TMessageType.CALL, self._seqid)
    args = parse_tokens_args()
    args.tokens = tokens
    args.outputFormat = outputFormat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_parse_tokens(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = parse_tokens_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "parse_tokens failed: unknown result");

  def parse_tagged_sentence(self, taggedSentence, outputFormat, divider):
    """
    Parameters:
     - taggedSentence
     - outputFormat
     - divider
    """
    self.send_parse_tagged_sentence(taggedSentence, outputFormat, divider)
    return self.recv_parse_tagged_sentence()

  def send_parse_tagged_sentence(self, taggedSentence, outputFormat, divider):
    self._oprot.writeMessageBegin('parse_tagged_sentence', TMessageType.CALL, self._seqid)
    args = parse_tagged_sentence_args()
    args.taggedSentence = taggedSentence
    args.outputFormat = outputFormat
    args.divider = divider
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_parse_tagged_sentence(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = parse_tagged_sentence_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "parse_tagged_sentence failed: unknown result");

  def lexicalize_parse_tree(self, tree):
    """
    Parameters:
     - tree
    """
    self.send_lexicalize_parse_tree(tree)
    return self.recv_lexicalize_parse_tree()

  def send_lexicalize_parse_tree(self, tree):
    self._oprot.writeMessageBegin('lexicalize_parse_tree', TMessageType.CALL, self._seqid)
    args = lexicalize_parse_tree_args()
    args.tree = tree
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_lexicalize_parse_tree(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = lexicalize_parse_tree_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "lexicalize_parse_tree failed: unknown result");

  def get_entities_from_text(self, text):
    """
    Parameters:
     - text
    """
    self.send_get_entities_from_text(text)
    return self.recv_get_entities_from_text()

  def send_get_entities_from_text(self, text):
    self._oprot.writeMessageBegin('get_entities_from_text', TMessageType.CALL, self._seqid)
    args = get_entities_from_text_args()
    args.text = text
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_entities_from_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_entities_from_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_entities_from_text failed: unknown result");

  def get_entities_from_tokens(self, tokens):
    """
    Parameters:
     - tokens
    """
    self.send_get_entities_from_tokens(tokens)
    return self.recv_get_entities_from_tokens()

  def send_get_entities_from_tokens(self, tokens):
    self._oprot.writeMessageBegin('get_entities_from_tokens', TMessageType.CALL, self._seqid)
    args = get_entities_from_tokens_args()
    args.tokens = tokens
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_entities_from_tokens(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_entities_from_tokens_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_entities_from_tokens failed: unknown result");

  def get_entities_from_trees(self, trees):
    """
    Parameters:
     - trees
    """
    self.send_get_entities_from_trees(trees)
    return self.recv_get_entities_from_trees()

  def send_get_entities_from_trees(self, trees):
    self._oprot.writeMessageBegin('get_entities_from_trees', TMessageType.CALL, self._seqid)
    args = get_entities_from_trees_args()
    args.trees = trees
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_entities_from_trees(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_entities_from_trees_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_entities_from_trees failed: unknown result");

  def resolve_coreferences_in_text(self, text):
    """
    Parameters:
     - text
    """
    self.send_resolve_coreferences_in_text(text)
    return self.recv_resolve_coreferences_in_text()

  def send_resolve_coreferences_in_text(self, text):
    self._oprot.writeMessageBegin('resolve_coreferences_in_text', TMessageType.CALL, self._seqid)
    args = resolve_coreferences_in_text_args()
    args.text = text
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resolve_coreferences_in_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resolve_coreferences_in_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resolve_coreferences_in_text failed: unknown result");

  def resolve_coreferences_in_tokenized_sentences(self, sentencesWithTokensSeparatedBySpace):
    """
    Parameters:
     - sentencesWithTokensSeparatedBySpace
    """
    self.send_resolve_coreferences_in_tokenized_sentences(sentencesWithTokensSeparatedBySpace)
    return self.recv_resolve_coreferences_in_tokenized_sentences()

  def send_resolve_coreferences_in_tokenized_sentences(self, sentencesWithTokensSeparatedBySpace):
    self._oprot.writeMessageBegin('resolve_coreferences_in_tokenized_sentences', TMessageType.CALL, self._seqid)
    args = resolve_coreferences_in_tokenized_sentences_args()
    args.sentencesWithTokensSeparatedBySpace = sentencesWithTokensSeparatedBySpace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resolve_coreferences_in_tokenized_sentences(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resolve_coreferences_in_tokenized_sentences_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resolve_coreferences_in_tokenized_sentences failed: unknown result");

  def resolve_coreferences_in_trees(self, trees):
    """
    Parameters:
     - trees
    """
    self.send_resolve_coreferences_in_trees(trees)
    return self.recv_resolve_coreferences_in_trees()

  def send_resolve_coreferences_in_trees(self, trees):
    self._oprot.writeMessageBegin('resolve_coreferences_in_trees', TMessageType.CALL, self._seqid)
    args = resolve_coreferences_in_trees_args()
    args.trees = trees
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resolve_coreferences_in_trees(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resolve_coreferences_in_trees_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resolve_coreferences_in_trees failed: unknown result");

  def evaluate_tregex_pattern(self, parseTree, tregexPattern):
    """
    Parameters:
     - parseTree
     - tregexPattern
    """
    self.send_evaluate_tregex_pattern(parseTree, tregexPattern)
    return self.recv_evaluate_tregex_pattern()

  def send_evaluate_tregex_pattern(self, parseTree, tregexPattern):
    self._oprot.writeMessageBegin('evaluate_tregex_pattern', TMessageType.CALL, self._seqid)
    args = evaluate_tregex_pattern_args()
    args.parseTree = parseTree
    args.tregexPattern = tregexPattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_evaluate_tregex_pattern(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = evaluate_tregex_pattern_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "evaluate_tregex_pattern failed: unknown result");

  def tag_text(self, untokenizedText):
    """
    Parameters:
     - untokenizedText
    """
    self.send_tag_text(untokenizedText)
    return self.recv_tag_text()

  def send_tag_text(self, untokenizedText):
    self._oprot.writeMessageBegin('tag_text', TMessageType.CALL, self._seqid)
    args = tag_text_args()
    args.untokenizedText = untokenizedText
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tag_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = tag_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tag_text failed: unknown result");

  def tag_tokenized_sentence(self, tokenizedSentence):
    """
    Parameters:
     - tokenizedSentence
    """
    self.send_tag_tokenized_sentence(tokenizedSentence)
    return self.recv_tag_tokenized_sentence()

  def send_tag_tokenized_sentence(self, tokenizedSentence):
    self._oprot.writeMessageBegin('tag_tokenized_sentence', TMessageType.CALL, self._seqid)
    args = tag_tokenized_sentence_args()
    args.tokenizedSentence = tokenizedSentence
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tag_tokenized_sentence(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = tag_tokenized_sentence_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tag_tokenized_sentence failed: unknown result");

  def untokenize_sentence(self, sentenceTokens):
    """
    Parameters:
     - sentenceTokens
    """
    self.send_untokenize_sentence(sentenceTokens)
    return self.recv_untokenize_sentence()

  def send_untokenize_sentence(self, sentenceTokens):
    self._oprot.writeMessageBegin('untokenize_sentence', TMessageType.CALL, self._seqid)
    args = untokenize_sentence_args()
    args.sentenceTokens = sentenceTokens
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_untokenize_sentence(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = untokenize_sentence_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "untokenize_sentence failed: unknown result");

  def tokenize_text(self, arbitraryText):
    """
    Parameters:
     - arbitraryText
    """
    self.send_tokenize_text(arbitraryText)
    return self.recv_tokenize_text()

  def send_tokenize_text(self, arbitraryText):
    self._oprot.writeMessageBegin('tokenize_text', TMessageType.CALL, self._seqid)
    args = tokenize_text_args()
    args.arbitraryText = arbitraryText
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tokenize_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = tokenize_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tokenize_text failed: unknown result");

  def sr_parse_tagged_sentence(self, taggedSentence, outputFormat, divider):
    """
    Parameters:
     - taggedSentence
     - outputFormat
     - divider
    """
    self.send_sr_parse_tagged_sentence(taggedSentence, outputFormat, divider)
    return self.recv_sr_parse_tagged_sentence()

  def send_sr_parse_tagged_sentence(self, taggedSentence, outputFormat, divider):
    self._oprot.writeMessageBegin('sr_parse_tagged_sentence', TMessageType.CALL, self._seqid)
    args = sr_parse_tagged_sentence_args()
    args.taggedSentence = taggedSentence
    args.outputFormat = outputFormat
    args.divider = divider
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sr_parse_tagged_sentence(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sr_parse_tagged_sentence_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sr_parse_tagged_sentence failed: unknown result");

  def sr_parse_text(self, untokenizedText, outputFormat):
    """
    Parameters:
     - untokenizedText
     - outputFormat
    """
    self.send_sr_parse_text(untokenizedText, outputFormat)
    return self.recv_sr_parse_text()

  def send_sr_parse_text(self, untokenizedText, outputFormat):
    self._oprot.writeMessageBegin('sr_parse_text', TMessageType.CALL, self._seqid)
    args = sr_parse_text_args()
    args.untokenizedText = untokenizedText
    args.outputFormat = outputFormat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sr_parse_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sr_parse_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sr_parse_text failed: unknown result");

  def sr_parse_tokens(self, tokenizedSentence, outputFormat):
    """
    Parameters:
     - tokenizedSentence
     - outputFormat
    """
    self.send_sr_parse_tokens(tokenizedSentence, outputFormat)
    return self.recv_sr_parse_tokens()

  def send_sr_parse_tokens(self, tokenizedSentence, outputFormat):
    self._oprot.writeMessageBegin('sr_parse_tokens', TMessageType.CALL, self._seqid)
    args = sr_parse_tokens_args()
    args.tokenizedSentence = tokenizedSentence
    args.outputFormat = outputFormat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sr_parse_tokens(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sr_parse_tokens_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sr_parse_tokens failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["ping"] = Processor.process_ping
    self._processMap["zip"] = Processor.process_zip
    self._processMap["parse_text"] = Processor.process_parse_text
    self._processMap["parse_tokens"] = Processor.process_parse_tokens
    self._processMap["parse_tagged_sentence"] = Processor.process_parse_tagged_sentence
    self._processMap["lexicalize_parse_tree"] = Processor.process_lexicalize_parse_tree
    self._processMap["get_entities_from_text"] = Processor.process_get_entities_from_text
    self._processMap["get_entities_from_tokens"] = Processor.process_get_entities_from_tokens
    self._processMap["get_entities_from_trees"] = Processor.process_get_entities_from_trees
    self._processMap["resolve_coreferences_in_text"] = Processor.process_resolve_coreferences_in_text
    self._processMap["resolve_coreferences_in_tokenized_sentences"] = Processor.process_resolve_coreferences_in_tokenized_sentences
    self._processMap["resolve_coreferences_in_trees"] = Processor.process_resolve_coreferences_in_trees
    self._processMap["evaluate_tregex_pattern"] = Processor.process_evaluate_tregex_pattern
    self._processMap["tag_text"] = Processor.process_tag_text
    self._processMap["tag_tokenized_sentence"] = Processor.process_tag_tokenized_sentence
    self._processMap["untokenize_sentence"] = Processor.process_untokenize_sentence
    self._processMap["tokenize_text"] = Processor.process_tokenize_text
    self._processMap["sr_parse_tagged_sentence"] = Processor.process_sr_parse_tagged_sentence
    self._processMap["sr_parse_text"] = Processor.process_sr_parse_text
    self._processMap["sr_parse_tokens"] = Processor.process_sr_parse_tokens

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    self._handler.ping()
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_zip(self, seqid, iprot, oprot):
    args = zip_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.zip()
    return

  def process_parse_text(self, seqid, iprot, oprot):
    args = parse_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = parse_text_result()
    result.success = self._handler.parse_text(args.text, args.outputFormat)
    oprot.writeMessageBegin("parse_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_parse_tokens(self, seqid, iprot, oprot):
    args = parse_tokens_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = parse_tokens_result()
    result.success = self._handler.parse_tokens(args.tokens, args.outputFormat)
    oprot.writeMessageBegin("parse_tokens", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_parse_tagged_sentence(self, seqid, iprot, oprot):
    args = parse_tagged_sentence_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = parse_tagged_sentence_result()
    result.success = self._handler.parse_tagged_sentence(args.taggedSentence, args.outputFormat, args.divider)
    oprot.writeMessageBegin("parse_tagged_sentence", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_lexicalize_parse_tree(self, seqid, iprot, oprot):
    args = lexicalize_parse_tree_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = lexicalize_parse_tree_result()
    result.success = self._handler.lexicalize_parse_tree(args.tree)
    oprot.writeMessageBegin("lexicalize_parse_tree", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_entities_from_text(self, seqid, iprot, oprot):
    args = get_entities_from_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_entities_from_text_result()
    result.success = self._handler.get_entities_from_text(args.text)
    oprot.writeMessageBegin("get_entities_from_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_entities_from_tokens(self, seqid, iprot, oprot):
    args = get_entities_from_tokens_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_entities_from_tokens_result()
    result.success = self._handler.get_entities_from_tokens(args.tokens)
    oprot.writeMessageBegin("get_entities_from_tokens", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_entities_from_trees(self, seqid, iprot, oprot):
    args = get_entities_from_trees_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_entities_from_trees_result()
    result.success = self._handler.get_entities_from_trees(args.trees)
    oprot.writeMessageBegin("get_entities_from_trees", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resolve_coreferences_in_text(self, seqid, iprot, oprot):
    args = resolve_coreferences_in_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resolve_coreferences_in_text_result()
    result.success = self._handler.resolve_coreferences_in_text(args.text)
    oprot.writeMessageBegin("resolve_coreferences_in_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resolve_coreferences_in_tokenized_sentences(self, seqid, iprot, oprot):
    args = resolve_coreferences_in_tokenized_sentences_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resolve_coreferences_in_tokenized_sentences_result()
    result.success = self._handler.resolve_coreferences_in_tokenized_sentences(args.sentencesWithTokensSeparatedBySpace)
    oprot.writeMessageBegin("resolve_coreferences_in_tokenized_sentences", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resolve_coreferences_in_trees(self, seqid, iprot, oprot):
    args = resolve_coreferences_in_trees_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resolve_coreferences_in_trees_result()
    result.success = self._handler.resolve_coreferences_in_trees(args.trees)
    oprot.writeMessageBegin("resolve_coreferences_in_trees", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_evaluate_tregex_pattern(self, seqid, iprot, oprot):
    args = evaluate_tregex_pattern_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = evaluate_tregex_pattern_result()
    result.success = self._handler.evaluate_tregex_pattern(args.parseTree, args.tregexPattern)
    oprot.writeMessageBegin("evaluate_tregex_pattern", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tag_text(self, seqid, iprot, oprot):
    args = tag_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tag_text_result()
    result.success = self._handler.tag_text(args.untokenizedText)
    oprot.writeMessageBegin("tag_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tag_tokenized_sentence(self, seqid, iprot, oprot):
    args = tag_tokenized_sentence_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tag_tokenized_sentence_result()
    result.success = self._handler.tag_tokenized_sentence(args.tokenizedSentence)
    oprot.writeMessageBegin("tag_tokenized_sentence", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_untokenize_sentence(self, seqid, iprot, oprot):
    args = untokenize_sentence_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = untokenize_sentence_result()
    result.success = self._handler.untokenize_sentence(args.sentenceTokens)
    oprot.writeMessageBegin("untokenize_sentence", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tokenize_text(self, seqid, iprot, oprot):
    args = tokenize_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tokenize_text_result()
    result.success = self._handler.tokenize_text(args.arbitraryText)
    oprot.writeMessageBegin("tokenize_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sr_parse_tagged_sentence(self, seqid, iprot, oprot):
    args = sr_parse_tagged_sentence_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sr_parse_tagged_sentence_result()
    result.success = self._handler.sr_parse_tagged_sentence(args.taggedSentence, args.outputFormat, args.divider)
    oprot.writeMessageBegin("sr_parse_tagged_sentence", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sr_parse_text(self, seqid, iprot, oprot):
    args = sr_parse_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sr_parse_text_result()
    result.success = self._handler.sr_parse_text(args.untokenizedText, args.outputFormat)
    oprot.writeMessageBegin("sr_parse_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sr_parse_tokens(self, seqid, iprot, oprot):
    args = sr_parse_tokens_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sr_parse_tokens_result()
    result.success = self._handler.sr_parse_tokens(args.tokenizedSentence, args.outputFormat)
    oprot.writeMessageBegin("sr_parse_tokens", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class ping_args(object):

  __slots__ = [ 
   ]

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ping_result(object):

  __slots__ = [ 
   ]

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class zip_args(object):

  __slots__ = [ 
   ]

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('zip_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class parse_text_args(object):
  """
  Attributes:
   - text
   - outputFormat
  """

  __slots__ = [ 
    'text',
    'outputFormat',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.LIST, 'outputFormat', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, text=None, outputFormat=None,):
    self.text = text
    self.outputFormat = outputFormat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.outputFormat = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString().decode('utf-8')
            self.outputFormat.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('parse_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.outputFormat))
      for iter6 in self.outputFormat:
        oprot.writeString(iter6.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class parse_text_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ParseTree, ParseTree.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = ParseTree()
            _elem12.read(iprot)
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('parse_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter13 in self.success:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class parse_tokens_args(object):
  """
  Attributes:
   - tokens
   - outputFormat
  """

  __slots__ = [ 
    'tokens',
    'outputFormat',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokens', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'outputFormat', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, tokens=None, outputFormat=None,):
    self.tokens = tokens
    self.outputFormat = outputFormat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokens = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString().decode('utf-8')
            self.tokens.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.outputFormat = []
          (_etype23, _size20) = iprot.readListBegin()
          for _i24 in xrange(_size20):
            _elem25 = iprot.readString().decode('utf-8')
            self.outputFormat.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('parse_tokens_args')
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.tokens))
      for iter26 in self.tokens:
        oprot.writeString(iter26.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.outputFormat))
      for iter27 in self.outputFormat:
        oprot.writeString(iter27.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class parse_tokens_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ParseTree, ParseTree.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ParseTree()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('parse_tokens_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class parse_tagged_sentence_args(object):
  """
  Attributes:
   - taggedSentence
   - outputFormat
   - divider
  """

  __slots__ = [ 
    'taggedSentence',
    'outputFormat',
    'divider',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'taggedSentence', None, None, ), # 1
    (2, TType.LIST, 'outputFormat', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'divider', None, None, ), # 3
  )

  def __init__(self, taggedSentence=None, outputFormat=None, divider=None,):
    self.taggedSentence = taggedSentence
    self.outputFormat = outputFormat
    self.divider = divider

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taggedSentence = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.outputFormat = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readString().decode('utf-8')
            self.outputFormat.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.divider = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('parse_tagged_sentence_args')
    if self.taggedSentence is not None:
      oprot.writeFieldBegin('taggedSentence', TType.STRING, 1)
      oprot.writeString(self.taggedSentence.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.outputFormat))
      for iter34 in self.outputFormat:
        oprot.writeString(iter34.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.divider is not None:
      oprot.writeFieldBegin('divider', TType.STRING, 3)
      oprot.writeString(self.divider.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class parse_tagged_sentence_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ParseTree, ParseTree.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ParseTree()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('parse_tagged_sentence_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class lexicalize_parse_tree_args(object):
  """
  Attributes:
   - tree
  """

  __slots__ = [ 
    'tree',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tree', None, None, ), # 1
  )

  def __init__(self, tree=None,):
    self.tree = tree

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tree = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('lexicalize_parse_tree_args')
    if self.tree is not None:
      oprot.writeFieldBegin('tree', TType.STRING, 1)
      oprot.writeString(self.tree.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class lexicalize_parse_tree_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('lexicalize_parse_tree_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class get_entities_from_text_args(object):
  """
  Attributes:
   - text
  """

  __slots__ = [ 
    'text',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
  )

  def __init__(self, text=None,):
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_entities_from_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class get_entities_from_text_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NamedEntity, NamedEntity.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = NamedEntity()
            _elem40.read(iprot)
            self.success.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_entities_from_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter41 in self.success:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class get_entities_from_tokens_args(object):
  """
  Attributes:
   - tokens
  """

  __slots__ = [ 
    'tokens',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokens', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, tokens=None,):
    self.tokens = tokens

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokens = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString().decode('utf-8')
            self.tokens.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_entities_from_tokens_args')
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.tokens))
      for iter48 in self.tokens:
        oprot.writeString(iter48.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class get_entities_from_tokens_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NamedEntity, NamedEntity.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = NamedEntity()
            _elem54.read(iprot)
            self.success.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_entities_from_tokens_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter55 in self.success:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class get_entities_from_trees_args(object):
  """
  Attributes:
   - trees
  """

  __slots__ = [ 
    'trees',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'trees', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, trees=None,):
    self.trees = trees

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.trees = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = iprot.readString().decode('utf-8')
            self.trees.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_entities_from_trees_args')
    if self.trees is not None:
      oprot.writeFieldBegin('trees', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.trees))
      for iter62 in self.trees:
        oprot.writeString(iter62.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class get_entities_from_trees_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NamedEntity, NamedEntity.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = NamedEntity()
            _elem68.read(iprot)
            self.success.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_entities_from_trees_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter69 in self.success:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class resolve_coreferences_in_text_args(object):
  """
  Attributes:
   - text
  """

  __slots__ = [ 
    'text',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
  )

  def __init__(self, text=None,):
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_coreferences_in_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class resolve_coreferences_in_text_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = iprot.readString().decode('utf-8')
            self.success.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_coreferences_in_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter76 in self.success:
        oprot.writeString(iter76.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class resolve_coreferences_in_tokenized_sentences_args(object):
  """
  Attributes:
   - sentencesWithTokensSeparatedBySpace
  """

  __slots__ = [ 
    'sentencesWithTokensSeparatedBySpace',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'sentencesWithTokensSeparatedBySpace', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, sentencesWithTokensSeparatedBySpace=None,):
    self.sentencesWithTokensSeparatedBySpace = sentencesWithTokensSeparatedBySpace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.sentencesWithTokensSeparatedBySpace = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString().decode('utf-8')
            self.sentencesWithTokensSeparatedBySpace.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_coreferences_in_tokenized_sentences_args')
    if self.sentencesWithTokensSeparatedBySpace is not None:
      oprot.writeFieldBegin('sentencesWithTokensSeparatedBySpace', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.sentencesWithTokensSeparatedBySpace))
      for iter83 in self.sentencesWithTokensSeparatedBySpace:
        oprot.writeString(iter83.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class resolve_coreferences_in_tokenized_sentences_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = iprot.readString().decode('utf-8')
            self.success.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_coreferences_in_tokenized_sentences_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter90 in self.success:
        oprot.writeString(iter90.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class resolve_coreferences_in_trees_args(object):
  """
  Attributes:
   - trees
  """

  __slots__ = [ 
    'trees',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'trees', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, trees=None,):
    self.trees = trees

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.trees = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = iprot.readString().decode('utf-8')
            self.trees.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_coreferences_in_trees_args')
    if self.trees is not None:
      oprot.writeFieldBegin('trees', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.trees))
      for iter97 in self.trees:
        oprot.writeString(iter97.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class resolve_coreferences_in_trees_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = iprot.readString().decode('utf-8')
            self.success.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_coreferences_in_trees_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter104 in self.success:
        oprot.writeString(iter104.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class evaluate_tregex_pattern_args(object):
  """
  Attributes:
   - parseTree
   - tregexPattern
  """

  __slots__ = [ 
    'parseTree',
    'tregexPattern',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'parseTree', None, None, ), # 1
    (2, TType.STRING, 'tregexPattern', None, None, ), # 2
  )

  def __init__(self, parseTree=None, tregexPattern=None,):
    self.parseTree = parseTree
    self.tregexPattern = tregexPattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.parseTree = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tregexPattern = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('evaluate_tregex_pattern_args')
    if self.parseTree is not None:
      oprot.writeFieldBegin('parseTree', TType.STRING, 1)
      oprot.writeString(self.parseTree.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.tregexPattern is not None:
      oprot.writeFieldBegin('tregexPattern', TType.STRING, 2)
      oprot.writeString(self.tregexPattern.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class evaluate_tregex_pattern_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = iprot.readString().decode('utf-8')
            self.success.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('evaluate_tregex_pattern_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter111 in self.success:
        oprot.writeString(iter111.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class tag_text_args(object):
  """
  Attributes:
   - untokenizedText
  """

  __slots__ = [ 
    'untokenizedText',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'untokenizedText', None, None, ), # 1
  )

  def __init__(self, untokenizedText=None,):
    self.untokenizedText = untokenizedText

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.untokenizedText = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tag_text_args')
    if self.untokenizedText is not None:
      oprot.writeFieldBegin('untokenizedText', TType.STRING, 1)
      oprot.writeString(self.untokenizedText.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class tag_text_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST,(TType.STRUCT,(TaggedToken, TaggedToken.thrift_spec))), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in xrange(_size112):
            _elem117 = []
            (_etype121, _size118) = iprot.readListBegin()
            for _i122 in xrange(_size118):
              _elem123 = TaggedToken()
              _elem123.read(iprot)
              _elem117.append(_elem123)
            iprot.readListEnd()
            self.success.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tag_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.LIST, len(self.success))
      for iter124 in self.success:
        oprot.writeListBegin(TType.STRUCT, len(iter124))
        for iter125 in iter124:
          iter125.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class tag_tokenized_sentence_args(object):
  """
  Attributes:
   - tokenizedSentence
  """

  __slots__ = [ 
    'tokenizedSentence',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokenizedSentence', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, tokenizedSentence=None,):
    self.tokenizedSentence = tokenizedSentence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokenizedSentence = []
          (_etype129, _size126) = iprot.readListBegin()
          for _i130 in xrange(_size126):
            _elem131 = iprot.readString().decode('utf-8')
            self.tokenizedSentence.append(_elem131)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tag_tokenized_sentence_args')
    if self.tokenizedSentence is not None:
      oprot.writeFieldBegin('tokenizedSentence', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.tokenizedSentence))
      for iter132 in self.tokenizedSentence:
        oprot.writeString(iter132.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class tag_tokenized_sentence_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TaggedToken, TaggedToken.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype136, _size133) = iprot.readListBegin()
          for _i137 in xrange(_size133):
            _elem138 = TaggedToken()
            _elem138.read(iprot)
            self.success.append(_elem138)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tag_tokenized_sentence_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter139 in self.success:
        iter139.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class untokenize_sentence_args(object):
  """
  Attributes:
   - sentenceTokens
  """

  __slots__ = [ 
    'sentenceTokens',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'sentenceTokens', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, sentenceTokens=None,):
    self.sentenceTokens = sentenceTokens

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.sentenceTokens = []
          (_etype143, _size140) = iprot.readListBegin()
          for _i144 in xrange(_size140):
            _elem145 = iprot.readString().decode('utf-8')
            self.sentenceTokens.append(_elem145)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('untokenize_sentence_args')
    if self.sentenceTokens is not None:
      oprot.writeFieldBegin('sentenceTokens', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.sentenceTokens))
      for iter146 in self.sentenceTokens:
        oprot.writeString(iter146.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class untokenize_sentence_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('untokenize_sentence_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class tokenize_text_args(object):
  """
  Attributes:
   - arbitraryText
  """

  __slots__ = [ 
    'arbitraryText',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'arbitraryText', None, None, ), # 1
  )

  def __init__(self, arbitraryText=None,):
    self.arbitraryText = arbitraryText

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.arbitraryText = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tokenize_text_args')
    if self.arbitraryText is not None:
      oprot.writeFieldBegin('arbitraryText', TType.STRING, 1)
      oprot.writeString(self.arbitraryText.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class tokenize_text_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST,(TType.STRING,None)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype150, _size147) = iprot.readListBegin()
          for _i151 in xrange(_size147):
            _elem152 = []
            (_etype156, _size153) = iprot.readListBegin()
            for _i157 in xrange(_size153):
              _elem158 = iprot.readString().decode('utf-8')
              _elem152.append(_elem158)
            iprot.readListEnd()
            self.success.append(_elem152)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tokenize_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.LIST, len(self.success))
      for iter159 in self.success:
        oprot.writeListBegin(TType.STRING, len(iter159))
        for iter160 in iter159:
          oprot.writeString(iter160.encode('utf-8'))
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class sr_parse_tagged_sentence_args(object):
  """
  Attributes:
   - taggedSentence
   - outputFormat
   - divider
  """

  __slots__ = [ 
    'taggedSentence',
    'outputFormat',
    'divider',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'taggedSentence', None, None, ), # 1
    (2, TType.LIST, 'outputFormat', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'divider', None, None, ), # 3
  )

  def __init__(self, taggedSentence=None, outputFormat=None, divider=None,):
    self.taggedSentence = taggedSentence
    self.outputFormat = outputFormat
    self.divider = divider

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taggedSentence = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.outputFormat = []
          (_etype164, _size161) = iprot.readListBegin()
          for _i165 in xrange(_size161):
            _elem166 = iprot.readString().decode('utf-8')
            self.outputFormat.append(_elem166)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.divider = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sr_parse_tagged_sentence_args')
    if self.taggedSentence is not None:
      oprot.writeFieldBegin('taggedSentence', TType.STRING, 1)
      oprot.writeString(self.taggedSentence.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.outputFormat))
      for iter167 in self.outputFormat:
        oprot.writeString(iter167.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.divider is not None:
      oprot.writeFieldBegin('divider', TType.STRING, 3)
      oprot.writeString(self.divider.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class sr_parse_tagged_sentence_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ParseTree, ParseTree.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ParseTree()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sr_parse_tagged_sentence_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class sr_parse_text_args(object):
  """
  Attributes:
   - untokenizedText
   - outputFormat
  """

  __slots__ = [ 
    'untokenizedText',
    'outputFormat',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'untokenizedText', None, None, ), # 1
    (2, TType.LIST, 'outputFormat', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, untokenizedText=None, outputFormat=None,):
    self.untokenizedText = untokenizedText
    self.outputFormat = outputFormat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.untokenizedText = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.outputFormat = []
          (_etype171, _size168) = iprot.readListBegin()
          for _i172 in xrange(_size168):
            _elem173 = iprot.readString().decode('utf-8')
            self.outputFormat.append(_elem173)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sr_parse_text_args')
    if self.untokenizedText is not None:
      oprot.writeFieldBegin('untokenizedText', TType.STRING, 1)
      oprot.writeString(self.untokenizedText.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.outputFormat))
      for iter174 in self.outputFormat:
        oprot.writeString(iter174.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class sr_parse_text_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ParseTree, ParseTree.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype178, _size175) = iprot.readListBegin()
          for _i179 in xrange(_size175):
            _elem180 = ParseTree()
            _elem180.read(iprot)
            self.success.append(_elem180)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sr_parse_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter181 in self.success:
        iter181.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class sr_parse_tokens_args(object):
  """
  Attributes:
   - tokenizedSentence
   - outputFormat
  """

  __slots__ = [ 
    'tokenizedSentence',
    'outputFormat',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokenizedSentence', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'outputFormat', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, tokenizedSentence=None, outputFormat=None,):
    self.tokenizedSentence = tokenizedSentence
    self.outputFormat = outputFormat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokenizedSentence = []
          (_etype185, _size182) = iprot.readListBegin()
          for _i186 in xrange(_size182):
            _elem187 = iprot.readString().decode('utf-8')
            self.tokenizedSentence.append(_elem187)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.outputFormat = []
          (_etype191, _size188) = iprot.readListBegin()
          for _i192 in xrange(_size188):
            _elem193 = iprot.readString().decode('utf-8')
            self.outputFormat.append(_elem193)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sr_parse_tokens_args')
    if self.tokenizedSentence is not None:
      oprot.writeFieldBegin('tokenizedSentence', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.tokenizedSentence))
      for iter194 in self.tokenizedSentence:
        oprot.writeString(iter194.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.outputFormat))
      for iter195 in self.outputFormat:
        oprot.writeString(iter195.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class sr_parse_tokens_result(object):
  """
  Attributes:
   - success
  """

  __slots__ = [ 
    'success',
   ]

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ParseTree, ParseTree.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ParseTree()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sr_parse_tokens_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)

